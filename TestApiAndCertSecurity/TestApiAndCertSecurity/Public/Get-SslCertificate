
<#

Inspired by https://github.com/PowerShell/PowerShell/issues/7092 to allow the creation of hashes of SSL certificates

$c = Get-SslCertificate "https://www.apteco.de"
$c | fl

Subject      : CN=www.apteco.co.uk, O=Apteco Limited, L=Warwick, C=GB
Issuer       : CN=DigiCert TLS RSA SHA256 2020 CA1, O=DigiCert Inc, C=US
Thumbprint   : D82B04907EA06A23E53A4053B3AB40F48CE6490A
FriendlyName : 
NotBefore    : 26.01.2022 01:00:00
NotAfter     : 25.02.2023 00:59:59
Extensions   : {System.Security.Cryptography.Oid, System.Security.Cryptography.Oid, System.Security.Cryptography.Oid, System.Security.Cryptography.Oidâ€¦}

#>

Function Get-SslCertificate {
    
    [CmdletBinding()]
    param(
        [Parameter(
            Position=0,
            Mandatory=$true,
            ValueFromPipeline=$true,
            ValueFromPipelineByPropertyName=$true)
        ]
        [Alias('FullName')]
        [String]$Url
    )

    Process {

        # Using C# to obtain certificate
        $Code = @'
            using System;
            using System.Collections.Generic;
            using System.Net.Http;
            using System.Net.Security;
            using System.Security.Cryptography.X509Certificates;

            namespace CertificateCapture
            {
                public class Utility
                {
                    public static Func<HttpRequestMessage,X509Certificate2,X509Chain,SslPolicyErrors,Boolean> ValidationCallback = 
                        (message, cert, chain, errors) => {
                            var newCert = new X509Certificate2(cert);
                            var newChain = new X509Chain();
                            newChain.Build(newCert);
                            CapturedCertificates.Add(new CapturedCertificate(){
                                Certificate =  newCert,
                                CertificateChain = newChain,
                                PolicyErrors = errors,
                                URI = message.RequestUri
                            });
                            return true; 
                        };
                    public static List<CapturedCertificate> CapturedCertificates = new List<CapturedCertificate>();
                }

                public class CapturedCertificate 
                {
                    public X509Certificate2 Certificate { get; set; }
                    public X509Chain CertificateChain { get; set; }
                    public SslPolicyErrors PolicyErrors { get; set; }
                    public Uri URI { get; set; }
                }
            }
'@

        # Differentiate between PS Core and Desktop
        if ($PSEdition -ne 'Core'){
            Add-Type -AssemblyName System.Net.Http
            if (-not ("CertificateCapture" -as [type])) {
                Add-Type $Code -ReferencedAssemblies System.Net.Http
            }
        } else {
            if (-not ("CertificateCapture" -as [type])) {
                Add-Type $Code
            }
        }

        $Certs = [CertificateCapture.Utility]::CapturedCertificates

        $Handler = [System.Net.Http.HttpClientHandler]::new()
        $Handler.ServerCertificateCustomValidationCallback = [CertificateCapture.Utility]::ValidationCallback
        $Client = [System.Net.Http.HttpClient]::new($Handler)
        $Result = $Client.GetAsync($Url).Result

        # Return
        $Certs[-1].Certificate
        
    }
}